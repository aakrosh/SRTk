#!/usr/bin/env python

"""Find the best split alignments for reads that carry signatures of SVs.
    usage:
      sr_sam [options] reference.fa [splitters.bam] unmapped.fq.gz

    where the options are:
        -h,--help      : print usage and quit
        -d,--debug     : print debug information
        -m,--maxsplits : allow up to maxsplits primary and supplemental
                         alignments [2]
        -c,--coverage  : require at least this fraction of the read to be aligned
                         in the primary alignment [0.5]
        -l,--lastz     : the path to the LASTZ (32 bit version) binary [lastz_32]
        -t,--threads   : number of threads to use [1]
        -1,--onlylz    : only use LASTZ. default is to use both BWA and LASTZ

    1. reference.fa is the reference sequence in fasta format.
    2. splitters.bam is a indexed BAM file with the clipped reads
    3. unmapped.fq.gz is a zipped file of sequences that did not align
       to the reference
"""

"""
    Notes
    -----
    1. splitters.bam and unmapped.fq.gz can be easily generated by  using 
       SAMBLASTER.
    2. There are three scenarios I can think of in case of splits. The following
       explanation assume only 2 splits of the query, but this can be 
       generalized:

        a.  The index [1,x] of the query are in one alignment, and [x+1,n] are 
            in the other.

            ---------------------
                                
                                 ----------------------

        b.  The index [1,x+k] of the query are in one alignment, and [x,n] are 
            in the other.

            ------------------------
                              ||||||
                              -------------------------

        c.  The index [1,x-k] of the query are in one alignment, and [x,n] are
            in the other.
            ---------------

                                 ----------------------
            An insertion where only one end of the sequence aligns to the
            reference would be a special case of this scenario.

    To-do
    -----
    1. The current version of this tool assumes soft-clipping and hard-clipping
       is ignored though the support for this should be added.
    2. The default output is in SAM format, so it can easily be input to LUMPY
       ,for example. An option I have to add is to additionally generate output
       in a block format I handle in some other tools.
"""

from sys import argv, stderr, stdin, exit, stdout
from getopt import getopt, GetoptError

from sr_sam import *

__author__ = "Aakrosh Ratan"
__email__  = "ratan@virginia.edu"

# do we want the debug information to be printed?
debug_flag = False

if __name__ == "__main__":
    try:
        opts, args = getopt(argv[1:], "hdm:c:l:t:1",["help", "debug", "maxsplits=", "coverage=", "lastz=", "threads=", "onlylz"])
    except GetoptError, err:
        print str(err)
        print >> stderr, __doc__
        exit(2) 

    maxsplits = 2
    coverage = 0.5
    lastz = "lastz_32"
    numthreads = 1
    onlylastz = False

    for o, a in opts:
        if o in ("-h", "--help"):
            print >> stderr, __doc__
            exit()
        elif o in ("-d", "--debug"):
            debug_flag = True
        elif o in ("-m", "--maxsplits"):
            maxsplits = int(a)
        elif o in ("-c", "--coverage"):
            coverage = float(a)
        elif o in ("-l", "--lastz"):
            lastz = a
        elif o in ("-t", "--threads"):
            numthreads = int(a)
        elif o in ("-1", "--onlylz"):
            onlylastz  = True
        else:
            assert False, "unhandled option"

    if len(args) not in [2,3]:
        print >> stderr, __doc__
        exit(3)

    if len(args) == 2:
        FindSplitAlignments(maxsplits,coverage,lastz,numthreads,onlylastz,args[0],args[1])
    else:
        FindSplitAlignments(maxsplits,coverage,lastz,numthreads,onlylastz,args[0],args[2],args[1])
